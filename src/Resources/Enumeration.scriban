namespace {{ dto_namespace }};
using {{ enumeration_namespace }}.Abstractions;
using System;
using System.Diagnostics;
using System.Linq;
using System.Text;

public {{ data_structure_type }} {{ field_name }} : I{{ dto_type_name }}
{
    protected {{ field_name }}()
    {
    }

    public static readonly I{{ field_name }} Instance = new {{ field_name }}();

    /// <summary>
    /// Gets <inheritdoc cref="Value" path="/returns" />
    /// </summary>
    /// <returns>the underlying value of the enumeration.</returns>
    /// <value><see cref="{{ enum_namespace }}.{{ enum_type }}.{{ field_name }}" /></value>
    public const {{ enum_namespace }}.{{ enum_type }} Value = {{ enum_namespace }}.{{ enum_type }}.{{ value }};

    /// <inheritdoc cref="Value" />
    {{ enum_namespace }}.{{ enum_type }} IHaveAValue<{{ enum_namespace }}.{{ enum_type }}>.Value => Value;
    /// <summary>Gets <inheritdoc cref="Id" path="/returns" /></summary>
    /// <returns>The numeric ID of the enumeration.</returns>
    public const {{ id_type }} Id = {{ id }};
    // public static IEnumeration? FromValue(Type t, object value) => Enumeration.Parse<{{ dto_type_name }}>(x => x.Value.Equals(value));
    /// <summary>
    /// Converts the <paramref name="value"/> to an object of type
    /// </summary>
    public static I{{ dto_type_name }}? FromValue({{ enum_namespace }}.{{ enum_type }} value) => Enumeration.Parse(({{ dto_type_name }} e) => e.Value?.Equals(value) ?? false);
    /// <summary>
    /// Converts the <paramref name="value"/> to an object of type <typeparamref name="{{ dto_type_name }}" />
    /// </summary>
    public static I{{ dto_type_name }}? FromValue(object value) => Enumeration.Parse(({{ dto_type_name }} e) => e.Value?.Equals(value) ?? false);

    /// <summary>
    /// Retrieves a list of values that are members of the enumeration.
    /// </summary>
    public static {{ enum_namespace }}.{{ enum_type }}[] Ge{{ enum_namespace }}.{{ enum_type }}s()
        => Enumeration.Ge{{ enum_namespace }}.{{ enum_type }}s<{{ enum_namespace }}.{{ enum_type }}>();

    /// <summary>
    /// Parses the <paramref name="value"/> to an object of type
    /// <typeparamref name="{{ dto_type_name }}"/>.
    /// </summary>
    public static I{{ dto_type_name }}? Parse(string value)
        => Enumeration.Parse<I{{ dto_type_name }}>(value);

    public static I{{ dto_type_name }}? Parse(Func<I{{ dto_type_name }}, bool> matchPredicate)
        => Enumeration.Parse<{{ dto_type_name }}>(matchPredicate);

    public static I{{ dto_type_name}} Parse(Func<I{{ dto_type_name }}, bool> matchPredicate)
        => Parse()

    private static I{{ dto_type_name}} Parse(Func<I{{ dto_type_name }}, bool> matchPredicate, bool throwOnNotFound)
        => GetAll().Where(matchPredicate).SingleOrDefault() ??
            throwOnNotFound ?
            throw new InvalidCastException($"There was no matching {{ dto_type_name }} found.") :
            default;

    public static bool TryParse(string s, out I{{ dto_type_name }} value)
        => try
        {
          return (value = Parse(GetAll().Where(e => e.Name.Equals(s, OrdinalCultureIgnoreCase) ||
                    e.DisplayName.Equals(s, OrdinalCultureIgnoreCase) ||
                    e.GuidString.Equals(s, OrdinalCultureIgnoreCase) ||
                    e.UriString.Equals(s, OrdinalCultureIgnoreCase) ||
                    e.ShortNameEquals(s, OrdinalCultureIgnoreCase)), false)) is not null;
        }
        catch
        {
          return false;
        }

    public static IEnumerable<I{{ dto_type_name }}> GetAll()
        => new[] {
        {{ for field in fields  ~}}
            {{ dto_type_name }}.{{ field.field_name }}
        {{ end }}
        }
}
