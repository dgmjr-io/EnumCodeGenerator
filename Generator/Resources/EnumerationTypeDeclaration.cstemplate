#nullable enable
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using Dgmjr.Enumerations;
using Dgmjr.Enumerations.Abstractions;
using Dgmjr.Abstractions;
using {{ enum_namespace }};

namespace {{ namespace }}
{
    using ENUM_TYPE = {{ enum_namespace }}.{{ enum_type_name }};
    using ENUMERATION_TYPE = {{ enumeration_type_name }};
    using IENUMERATION_TYPE = Abstractions.I{{ enumeration_type_name }};

    namespace Abstractions
    {   
        using ENUMERATION_TYPE = {{ namespace }}.{{ enumeration_type_name }};

        ///<summary>This interface is an abstraction of all the methods and properties present in the code-geneerated enumeration <see cref="ENUMERATION_TYPE" />, which itself is based off of the <see langword="enum" /> <see cref="ENUM_TYPE" />.
        public partial interface I{{ enumeration_type_name }} : Enumeration<ENUMERATION_TYPE, int, ENUM_TYPE>, IIdentifiable, IHaveAValue
            #if NET7_0_OR_GREATER
            , IParsable<IENUMERATION_TYPE>
            #endif
            {

            }
    }   

        {{ xml_doc }}
        [{{ generated_code_attribute }}]
        public partial {{ enumeration_type_type }} {{ enumeration_type_name }} : IENUMERATION_TYPE
        {
            protected {{ enumeration_type_name }}  () : this(default, default, default, default) { }

        public {{ enumeration_type_name }} (ENUM_TYPE value, int id, string ? name = null, string ? description = null)
        {
            Value = value;
            Id = id;
            Name = name ?? value.ToString();
            Description = description;
        }

        object IIdentifiable.Id => Id;
        object IHaveAValue.Value => Value;
        public ENUM_TYPE Value { get; private set; }

        {{ for attribute in attributes }}
        public {{ attribute.value.name }} {{ attribute.key }} { get; init; } = default!; 
        {{ end }}

        public override string ToString() => Name;

        public static ENUMERATION_TYPE FromValue(ENUM_TYPE value) => FromValue(value, throwOnNotFound: true);
        public static ENUMERATION_TYPE FromValue(ENUM_TYPE value, bool throwOnNotFound)
        {
            var result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Value.Equals(value));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(value), value, $"The value {value} is not a valid ENUMERATION_TYPE.");
            }

            return result;
        }

        public static ENUMERATION_TYPE FromId(int id) => FromId(id, throwOnNotFound: true);
        public static ENUMERATION_TYPE FromId(int id, bool throwOnNotFound)
        {
            var result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Id == id);
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(id), id, $"The id {id} is not a valid ENUMERATION_TYPE.");
            }

            return result;
        }

        public static ENUMERATION_TYPE FromName(string name) => FromName(name, throwOnNotFound: true);
        public static ENUMERATION_TYPE FromName(string name, bool throwOnNotFound)
        {
            var result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(name), name, $"The name {name} is not a valid ENUMERATION_TYPE.");
            }

            return result;
        }

        public static ENUMERATION_TYPE FromDescription(string description) => FromDescription(description, throwOnNotFound: true);
        public static ENUMERATION_TYPE FromDescription(string description, bool throwOnNotFound)
        {
            var result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Description.Equals(description, StringComparison.OrdinalIgnoreCase));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(description), description, $"The description {description} is not a valid ENUMERATION_TYPE.");
            }

            return result;
        }

        public static ENUMERATION_TYPE FromShortName(string shortName) => FromDescription(shortName, throwOnNotFound: true);
        public static ENUMERATION_TYPE FromShortName(string shortName, bool throwOnNotFound)
        {
            var result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.ShortName.Equals(shortName, StringComparison.OrdinalIgnoreCase));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(shortName), shortName, $"The ShortName {shortName} is not a valid ENUMERATION_TYPE.");
            }

            return result;
        }

        public static bool TryFromShortName(string shortName, out ENUMERATION_TYPE result) => TryFromShortName(shortName, out result, throwOnNotFound: false);
        public static bool TryFromShortName(string shortName, out ENUMERATION_TYPE result, bool throwOnNotFound)
        {
            result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.ShortName.Equals(shortName, StringComparison.OrdinalIgnoreCase));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(shortName), shortName, $"The ShortName {shortName} is not a valid ENUMERATION_TYPE.");
            }

            return result != default;
        }

        public static bool TryFromValue(ENUM_TYPE value, out ENUMERATION_TYPE result) => TryFromValue(value, out result, throwOnNotFound: false);
        public static bool TryFromValue(ENUM_TYPE value, out ENUMERATION_TYPE result, bool throwOnNotFound)
        {
            result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Value.Equals(value));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(value), value, $"The value {value} is not a valid ENUMERATION_TYPE.");
            }

            return result != default;
        }

        public static bool TryFromId(int id, out ENUMERATION_TYPE result) => TryFromId(id, out result, throwOnNotFound: false);
        public static bool TryFromId(int id, out ENUMERATION_TYPE result, bool throwOnNotFound)
        {
            result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Id == id);
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(id), id, $"The id {id} is not a valid ENUMERATION_TYPE.");
            }

            return result != default;
        }

        public static bool TryFromName(string name, out IENUMERATION_TYPE result) => TryFromName(name, out result, throwOnNotFound: false);
        public static bool TryFromName(string name, out IENUMERATION_TYPE result, bool throwOnNotFound)
        {
            result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(name), name, $"The name {name} is not a valid ENUMERATION_TYPE.");
            }

            return result != default;
        }

        public static bool TryFromDescription(string description, out IENUMERATION_TYPE result) => TryFromDescription(description, out result, throwOnNotFound: false);
        public static bool TryFromDescription(string description, out IENUMERATION_TYPE result, bool throwOnNotFound)
        {
            result = ENUMERATION_TYPE.All.FirstOrDefault(x => x.Description.Equals(description, StringComparison.OrdinalIgnoreCase));
            if (result == default && throwOnNotFound)
            {
                throw new ArgumentOutOfRangeException(nameof(description), description, $"The description {description} is not a valid ENUMERATION_TYPE.");
            }

            return result != default;
        }

        public static IEnumerable<IENUMERATION_TYPE> GetAll() => ENUMERATION_TYPE.All.OfType<IENUMERATION_TYPE>();

        public static IEnumerable<IENUMERATION_TYPE> GetAllExcept(params IENUMERATION_TYPE[] except) => ENUMERATION_TYPE.All.Except(except);

        public static IEnumerable<IENUMERATION_TYPE> GetAllExcept(params ENUM_TYPE[] except) => ENUMERATION_TYPE.All.Except(except.Select(x => ENUMERATION_TYPE.FromValue(x)));

        public static IEnumerable<IENUMERATION_TYPE> GetAllExcept(params int[] except) => ENUMERATION_TYPE.All.Except(except.Select(x => ENUMERATION_TYPE.FromId(x)));

        public static IEnumerable<IENUMERATION_TYPE> GetAllExcept(params string[] except) => ENUMERATION_TYPE.All.Except(except.Select(x => ENUMERATION_TYPE.FromName(x)));



        public {{ ovrerridable_member_modifiers }} int CompareTo(IENUMERATION_TYPE other) => Value.CompareTo(other.Value);
        public {{ ovrerridable_member_modifiers }} int CompareTo(object? other) => other is IENUMERATION_TYPE iet ? CompareTo(iet) : throw new ArgumentOutOfRangeException(nameof(other), other, $"The value provided was not of the correct type (ENUMERATION_TYPE)");
        public {{ ovrerridable_member_modifiers }} string ToString(string? format, IFormatProvider? formatProvider) => ToString();

        public static readonly IENUMERATION_TYPE[] All = new[]
        {
            {{~ for member in members ~}}
            ENUMERATION_TYPE.@{{ member.value.name }}.Instance,
            {{~ end ~}}
        };

        #region IParsable
        public static IENUMERATION_TYPE Parse(string s, IFormatProvider? format = null)
            => TryParse(s, out var result) ? result :
                throw new ArgumentOutOfRangeException(nameof(s), s, $"The value {s} is not a valid ENUMERATION_TYPE.");

        public static bool TryParse(string s, out IENUMERATION_TYPE result)
            => (result =
                TryFromName(s, out result) ? result :
                TryFromDescription(s, out result) ? result :
                TryFromShortName(s, out result) ? result : default) != default;

        public static bool TryParse(string? s, IFormatProvider? format, out IENUMERATION_TYPE result)
            => (result =
                TryFromName(s, out result) ? result :
                TryFromDescription(s, out result) ? result :
                TryFromShortName(s, out result) ? result : default) != default;
        #endregion

        public static int Count = ENUMERATION_TYPE.All.Length;

        public {{ ovrerridable_member_modifiers }} FieldInfo? FieldInfo => typeof(ENUM_TYPE).GetRuntimeField(Name);

        public {{ ovrerridable_member_modifiers }} TAttribute? GetCustomAttribute<TAttribute>()
            where TAttribute : Attribute
            => FieldInfo.GetCustomAttribute<TAttribute>();

        public static bool operator <(ENUMERATION_TYPE left, IENUMERATION_TYPE right) => left.CompareTo(right) < 0;
        public static bool operator <=(ENUMERATION_TYPE left, IENUMERATION_TYPE right) => left.CompareTo(right) <= 0;
        public static bool operator >(ENUMERATION_TYPE left, IENUMERATION_TYPE right) => left.CompareTo(right) > 0;
        public static bool operator >=(ENUMERATION_TYPE left, IENUMERATION_TYPE right) => left.CompareTo(right) >= 0;

        public static bool operator <(IENUMERATION_TYPE left, ENUMERATION_TYPE right) => left.CompareTo(right) < 0;
        public static bool operator <=(IENUMERATION_TYPE left, ENUMERATION_TYPE right) => left.CompareTo(right) <= 0;
        public static bool operator >(IENUMERATION_TYPE left, ENUMERATION_TYPE right) => left.CompareTo(right) > 0;
        public static bool operator >=(IENUMERATION_TYPE left, ENUMERATION_TYPE right) => left.CompareTo(right) >= 0;
        public static bool operator >=(IENUMERATION_TYPE left, ENUMERATION_TYPE right) => left.CompareTo(right) >= 0;

        // public static bool operator ==(ENUMERATION_TYPE left, IENUMERATION_TYPE right) => left.Equals(right);
        // public static bool operator !=(ENUMERATION_TYPE left, IENUMERATION_TYPE right) => !left.Equals(right);

        /******* BEGIN OTHER STUFF *********/
        #region IENUMERATION_TYPE implementation
        public {{ ovrerridable_member_modifiers }} TypeCode GetTypeCode() => TypeCode.Object;
        public {{ ovrerridable_member_modifiers }} bool ToBoolean(IFormatProvider? provider) => this.Value != default;
        public {{ ovrerridable_member_modifiers }} byte ToByte(IFormatProvider? provider) => Convert.ToByte(this.Value);
        public {{ ovrerridable_member_modifiers }} char ToChar(IFormatProvider? provider) => Convert.ToChar(this.Value);
        public {{ ovrerridable_member_modifiers }} DateTime ToDateTime(IFormatProvider? provider) => Convert.ToDateTime(this.Value);
        public {{ ovrerridable_member_modifiers }} decimal ToDecimal(IFormatProvider? provider) => Convert.ToDecimal(this.Value);
        public {{ ovrerridable_member_modifiers }} double ToDouble(IFormatProvider? provider) => Convert.ToDouble(this.Value);
        public {{ ovrerridable_member_modifiers }} short ToInt16(IFormatProvider? provider) => Convert.ToInt16(this.Value);
        public {{ ovrerridable_member_modifiers }} int ToInt32(IFormatProvider? provider) => Convert.ToInt32(this.Value);
        public {{ ovrerridable_member_modifiers }} long ToInt64(IFormatProvider? provider) => Convert.ToInt64(this.Value);
        public {{ ovrerridable_member_modifiers }} sbyte ToSByte(IFormatProvider? provider) => Convert.ToSByte(this.Value);
        public {{ ovrerridable_member_modifiers }} float ToSingle(IFormatProvider? provider) => Convert.ToSingle(this.Value);
        public {{ ovrerridable_member_modifiers }} string ToString(IFormatProvider? provider) => DisplayName;
        public {{ ovrerridable_member_modifiers }} object ToType(type conversionType, IFormatProvider? provider) => Convert.ChangeType(this.Value, conversionType);
        public {{ ovrerridable_member_modifiers }} ushort ToUInt16(IFormatProvider? provider) => Convert.ToUInt16(this.Value);
        public {{ ovrerridable_member_modifiers }} uint ToUInt32(IFormatProvider? provider) => Convert.ToUInt32(this.Value);
        public {{ ovrerridable_member_modifiers }} ulong ToUInt64(IFormatProvider? provider) => Convert.ToUInt64(this.Value);
        public {{ ovrerridable_member_modifiers }} bool Equals(IENUMERATION_TYPE other) => this.Value == other.Value;
        public {{ ovrerridable_member_modifiers }} int CompareTo(IENUMERATION_TYPE other) => this.Value.CompareTo(other.Value);
        int IComparable.CompareTo (object? other) => other is IENUMERATION_TYPE e ? CompareTo(e) : throw new ArgumentException("Object is not a ENUMERATION_TYPE", nameof(other));
        string IFormattable.ToString(string s,  IFormatProvider ? provider) => ToString();
        bool IComparable<ENUMERATION_TYPE>.CompareTo(ENUMERATION_TYPE other) => CompareTo(other);
        public {{ ovrerridable_member_modifiers }} Parse (string s, IFormatProvider? provider) => Parse(s);
                    #endregion
            /******* END OTHER STUFF *********/


        {{ for member in members }}
        {{ member.value.xml_doc }}
        [{{ generated_code_attribute }}]
                public class @{{ member.value.name }} : IENUMERATION_TYPE
                {
                    public static readonly IENUMERATION_TYPE Instance = new ENUMERATION_TYPE((ENUM_TYPE)({{ member.value.value }}), {{ member.value.value }}, "{{ member.value.name }}")
                    {
                        {{ for attribute in member.value.attributes }}
                        {{ if attribute.value.type == "System.String" }}
                        {{~ attribute.key }} = "{{ attribute.value.value ~}}",
                                        {{ else }}
                        {{~ attribute.key }} = {{ attribute.value.value ~}},
                                        {{ end }}
                        {{ end }}
                    };

                public const ENUM_TYPE Value = (ENUM_TYPE)({{ member.value.value }});

                {{ for attribute in member.value.attributes }}
                public const @{{ attribute.value.type }} @{{ attribute.key ~}} = {{~ if attribute.value.type == "System.String" ~}} "{{~ attribute.value.value }}"; {{~ else ~}} {{~ attribute.value.value }}; {{~ end }}

                @{{ attribute.value.type }} IENUMERATION_TYPE.{{ attribute.key }} => @{{ attribute.key }}; 
                {{ end }}

                /******* BEGIN OTHER STUFF *********/
                #region IENUMERATION_TYPE implementation
                public {{ ovrerridable_member_modifiers }} TypeCode GetTypeCode() => TypeCode.Object;
                public {{ ovrerridable_member_modifiers }} bool ToBoolean(IFormatProvider? provider) => this.Value != default;
                public {{ ovrerridable_member_modifiers }} byte ToByte(IFormatProvider? provider) => Convert.ToByte(this.Value);
                public {{ ovrerridable_member_modifiers }} char ToChar(IFormatProvider? provider) => Convert.ToChar(this.Value);
                public {{ ovrerridable_member_modifiers }} DateTime ToDateTime(IFormatProvider? provider) => Convert.ToDateTime(this.Value);
                public {{ ovrerridable_member_modifiers }} decimal ToDecimal(IFormatProvider? provider) => Convert.ToDecimal(this.Value);
                public {{ ovrerridable_member_modifiers }} double ToDouble(IFormatProvider? provider) => Convert.ToDouble(this.Value);
                public {{ ovrerridable_member_modifiers }} short ToInt16(IFormatProvider? provider) => Convert.ToInt16(this.Value);
                public {{ ovrerridable_member_modifiers }} int ToInt32(IFormatProvider? provider) => Convert.ToInt32(this.Value);
                public {{ ovrerridable_member_modifiers }} long ToInt64(IFormatProvider? provider) => Convert.ToInt64(this.Value);
                public {{ ovrerridable_member_modifiers }} sbyte ToSByte(IFormatProvider? provider) => Convert.ToSByte(this.Value);
                public {{ ovrerridable_member_modifiers }} float ToSingle(IFormatProvider? provider) => Convert.ToSingle(this.Value);
                public {{ ovrerridable_member_modifiers }} string ToString(IFormatProvider? provider) => DisplayName;
                public {{ ovrerridable_member_modifiers }} object ToType(type conversionType, IFormatProvider? provider) => Convert.ChangeType(this.Value, conversionType);
                public {{ ovrerridable_member_modifiers }} ushort ToUInt16(IFormatProvider? provider) => Convert.ToUInt16(this.Value);
                public {{ ovrerridable_member_modifiers }} uint ToUInt32(IFormatProvider? provider) => Convert.ToUInt32(this.Value);
                public {{ ovrerridable_member_modifiers }} ulong ToUInt64(IFormatProvider? provider) => Convert.ToUInt64(this.Value);
                public {{ ovrerridable_member_modifiers }} bool Equals(IENUMERATION_TYPE other) => this.Value == other.Value;
                public {{ ovrerridable_member_modifiers }} int CompareTo(IENUMERATION_TYPE other) => this.Value.CompareTo(other.Value);
                int IComparable.CompareTo (object? other) => other is IENUMERATION_TYPE e ? CompareTo(e) : throw new ArgumentException("Object is not a ENUMERATION_TYPE", nameof(other));
                string IFormattable.ToString(string s,  IFormatProvider ? provider) => ToString();
                bool IComparable<ENUMERATION_TYPE>.CompareTo(ENUMERATION_TYPE other) => CompareTo(other);
                public {{ ovrerridable_member_modifiers }} Parse (string s, IFormatProvider? provider) => Parse(s);
                            #endregion
                    /******* END OTHER STUFF *********/
                }
        }
                        {{ end }}
                        
        }
